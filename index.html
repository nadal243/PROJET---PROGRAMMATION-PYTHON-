
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Mon Portfolio</title>
  <link rel="stylesheet" href="style.css">

  <!-- Highlight.js pour coloration syntaxique -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script>hljs.highlightAll();</script>

  <style>
    pre {
      background: #f0f0f0;
      padding: 1em;
      overflow-x: auto;
      border-radius: 8px;
    }
    details {
      margin-top: 1em;
    }
  </style>
</head>
<body>
  <header>
    <h1>Bienvenue sur mon portfolio</h1>
    <p>Je m'appelle nadal NGAKI MUPATI, je suis étudiant en deuxième année de licence sciences pour l'ingénieur, voici mes diffétents projets personnels et académiques concernant la programmation informatique.</p>
  </header>

  <section>
    <h2>Mes projets</h2>
    <ul>
      <li>
        <strong>Projet 1 : Jeu vidéo - Eco-Guerrier</strong><br>
        <p>
          Une simulation ludique en Python avec interface Tkinter et gestion de carte maritime. Le joueur incarne un navire écologique (OMI)
          chargé d'intercepter les pollueurs (OP) et de protéger les zones marines.
        </p>
        <ul>
          <li>Déplacement en temps réel sur carte avec collisions</li>
          <li>Ajout de zones protégées et traitement des nappes d’hydrocarbures</li>
          <li>Gestion d’un budget, chronomètre, enregistrement de score</li>
          <li>Cheat codes pour interagir avec l'environnement (nappes, plateformes...)</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Projet : Eco guerrir
Auteur : NGAKI MUPATI NADAL
"""

#Modules importés
from tkinter import *
import random
import math
import numpy as np
import tkinter as tk
from tkinter import messagebox
import matplotlib.pyplot as plt

# ----------------------------------------------------------------
# Variables globales
# ----------------------------------------------------------------

#Liste des entites mobiles (ID)
entitesMobiles=[]
#Liste des entités mobiles
typesEntiteMobile=[]
TYPE_ORGA_MARITIME=1
TYPE_ORGA_PETROL=5
TYPE_NAPPE_HYDRO=6

#A intégrer
etats_chargement=[]
ETAT_CHARGEMENT_MIN=0
ETAT_CHARGEMENT_MAX=100
#DEGAT_ORGA_PETROL=10

#Coordonnées initiales de tous les navires
coord_iEntitesMobiles_Init=[]#Abscisse Navires
coord_jEntitesMobiles_Init=[]#Ordonnée Navires

#Coordonnées actuelles de tous les navires
coord_iEntitesMobiles=[]#Abscisse Navires >> nombre réél à convertir en entier pour utiliser en coordonnées matricielle
coord_jEntitesMobiles=[]#Ordonnée Navires


#Vitesses actuelles de tous les navires
vitX=[]
vitY=[]
#Distance incrémentée à chaque déplacement
VIT_MAX_OrgaMaritime = 0.04
VIT_MAX_OrgaPetrole = 0.03

### Legende des Matrices de décor ###
#Zones naviguables
ZN=10#Zone maritime neutre : non explitée/non protégée
ZP=11#Zone maritime protégée
BP=20#Base portuaire pétrolière
PP=30#Plateforme pétrolière
BM=40#Base portuaire OMI
CG=60     #coin gauche haut 
CD=70     #coin droite haut
CDh=80    #coin droite bas 
CGh=90    #coin gache bas
CH=100    #cote haut 
CB=110    #cote bas
cG=120    #cote gauche
cD=140    #cote droite 

#Zones non naviguable
ZT=50#Zone terrestre




#Matrice de la carte du Niveau 1
matValCarteN1 = [
    [CG, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, CG, CH, CD, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, cG, ZT, cD, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, CGh, CB, CDh, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, PP, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, BM, ZP, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, BP, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [CGh, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CDh]
]



matValCarteN1_initial=np.copy(matValCarteN1)#Copie pout conservation des valeurs initiales durant la simulation

#Dimension de chaque case en pixel
LARG_CASE=40#Largeur
HAUT_CASE=40#Hauteur

#Dimensions
LARG_CANVAS = len(matValCarteN1)*LARG_CASE
HAUT_CANVAS = len(matValCarteN1[0])*HAUT_CASE

#Etat des animations et déplacements
etat_actif_depl_anim = False

#Demande d'arrêt
dde_arret = False

#Gestion du budget
budgetOM=budgetOM_INIT=2000
budgetOP=budgetOP_INIT=2000
tarifSANCTION=500#Tarif d'une sanction en cas de décrouverte d'une nappe
tarifVENTE=100#Tarif d'une vente de pétrole
tarifTRAITEMENT=100#Tarif de traitement de déchets
tarifDEGAT=500#Tarif de destruction d'une zone protégée

#durée de simulation
dureeSimulation=0#en s
tpsRafraichissement=0.1#en s
# dureePP_Initiale=10#en s
dureePP_Initiale=20#en s
# dureePP=10#en s
dureePP=20#en s
# dureeZP_Initiale=10#en
dureeZP_Initiale=20#en s
#dureeZP=10#en s
dureeZP=20#en s

#---------------------------------------------------------------------------------------------------------
# LES DIFFERENTS VARRIABLES QUE J'AI INITIALISEES TOUT AU DEBUT 
#---------------------------------------------------------------------------------------------------------

NAVIRE_PIRATE=4    # initialisation de mon navire pirate 
VIT_MAX_NAVIRE_PIRATE = 0.06    #vitesse du navire pirate

# temps pour le chronometre 
duree_partie = 0  # Temps écoulé en secondes
chrono_actif = False  # Indique si le chronomètre est en cours

FICHIER_BUDGET = "budget.txt"  # declaration du budget comme fichier txt

nom_utilisateur = input("entrez votre nom, celui-ci doit etre identique avec le nom que vous saisirez en debut de partie  : ")   # pour l'association du record avec le nom de l'utilisateur

#suivi du budget et le temps pour le graphe
temps = []
budgets_om = []
budgets_op = []



# -----------------------------------------------------------------------------------------------------------
# FONCTIONS
# -----------------------------------------------------------------------------------------------------------


#-----------------------------------------------------------------------------------------------------------    
# Cheat Code 
#-----------------------------------------------------------------------------------------------------------

def afficher_tutoriel():
    """ Fonction pour afficher le tutoriel
    """
    tutoriel_window = tk.Toplevel(root)
    tutoriel_window.title("Tutoriel")
    texte_tutoriel = (
        "Bienvenue dans ce jeu Eco-Guerrier !\n\n"
        "Objectif :\n"
        "- Contrôlez le navire OM pour perturber le trafic de l'OP et lutter contre la pollution maritime.\n\n"

        "Instructions du jeu :\n"

        "- Flèches directionnelles : Déplacer le navire OM\n"
        
        "- les Cheat Codes :\n"

        "- Touche 'n' : Supprimer les nappes d'hydrocarbures\n"

        "- Touche 'v' : Ajouter une zone protégée\n"

        "- Touche 'p' : Déplacer la plateforme pétrolière\n"

        "- Touche 'Espace' : Démarrer/Arrêter la simulation\n"

        "Bonne chance !"
    )

    tk.Label(tutoriel_window, text=texte_tutoriel, justify="left", font=("calibri", 12)).pack(padx=20, pady=20)
    
     
def suppression_des_nappes_hydocarbures ():
    """suppression de la nappe hydrocarbure avec la touche n"""
    global budgetOM, budgetOP
    for i in range(len(entitesMobiles)-1, -1, -1): #pour un parcours inversé afin d'éviter les problemes de suppresion 
        if typesEntiteMobile[i]==TYPE_NAPPE_HYDRO and etats_chargement[i]==ETAT_CHARGEMENT_MAX:
            #suppression de l'image 
            gestionCanvas.delete(entitesMobiles[i])
            #suppresion des données reletives aux nappes 
            coord_iEntitesMobiles_Init.pop(i)
            coord_jEntitesMobiles_Init.pop(i)
            coord_iEntitesMobiles.pop(i)
            coord_jEntitesMobiles.pop(i)
            vitX.pop(i)
            vitY.pop(i)
            entitesMobiles.pop(i)
            typesEntiteMobile.pop(i)
            etats_chargement.pop(i)
            budgetOM+=tarifTRAITEMENT  #augmentation du budget de OM
            budgetOP-=tarifSANCTION    #reduction du budget de OP
            lblBudgetOM.config(text="budget OM :"+ str(budgetOM))
            lblBudgetOP.config(text="budget OP :"+ str(budgetOP))
            print("la suppression de la nappe a été un succes !") #message pour le suivi
            break  # pour sortir apres avoir supprimé une nappe hydrocarbure 

def ajout_de_nouvelles_zones_protegées():
    """Ajoute une nouvelle zone protégée sur une zone neutre (ZN)."""
    global matValCarteN1
    newCoordZP = getCoordAleatoire([ZN], True, 1)
    matValCarteN1[newCoordZP[1]][newCoordZP[0]] = ZP  # Mettre à jour la matrice
    gestionCanvas.itemconfig(matImgCarteN1[newCoordZP[1]][newCoordZP[0]], image=imgZP)  # Mise à jour de l'affichage
    print(" Nouvelle zone protégée ajoutée !")  # Message pour suivi

def deplacement_de_la_plateforme_petroliere():
    """Déplace la plateforme pétrolière vers une nouvelle zone neutre."""
    global matValCarteN1
    oldCoordPP = getCelluleZoneUnique(PP)
    newCoordPP = getCoordAleatoire([ZN], True, 1)
    
    # Mise à jour des matrices
    matValCarteN1[newCoordPP[1]][newCoordPP[0]] = PP
    matValCarteN1[oldCoordPP[1]][oldCoordPP[0]] = ZN
    
    # Mise à jour de l'affichage
    gestionCanvas.itemconfig(matImgCarteN1[oldCoordPP[1]][oldCoordPP[0]], image=imgZN)
    gestionCanvas.itemconfig(matImgCarteN1[newCoordPP[1]][newCoordPP[0]], image=imgPP)
    print("Plateforme pétrolière déplacée avec succès !")  # Message pour suivi
    
#----------------------------------------------------------------------------------------------------------   
# 5.2 Menu principal
#----------------------------------------------------------------------------------------------------------

def lancerSimulation():
    """ Fonction pour afficher le tutoriel
    """
    depart()                 # pour declencher le depart en appuyant sur le bouton respectif
    fen_princ.deiconify()    # pour lancer la simulation en appuyant sur le bouton respectif

#------------------------------------------------------------------------------------------------
# Affichage de la durée de la partie
#------------------------------------------------------------------------------------------------

def miseAJourDuree():
    """ creation d'une fonction pour la mise à jour du chronometre""" 
    global duree_partie, chrono_actif

    if chrono_actif:  # Vérifie si le chronomètre est actif
        duree_partie += 1  # Incrémente le temps de jeu
        lblDureePartie.config(text=f"Durée : {duree_partie}s")  # Met à jour l'affichage
        fen_princ.after(1000, miseAJourDuree)  # Rappelle la fonction après 1 seconde

#-------------------------------------------------------------------------------------------------        
# Sauvegarde des Budgets & Record 
#-------------------------------------------------------------------------------------------------

def charger_record():
    """Charge le record (budget max) depuis le fichier."""
    budget1 = []
    try:
        fichier = open(FICHIER_BUDGET, "r")
        lignes = fichier.readlines()
        fichier.close()
        
        for ligne in lignes:
            elements = ligne.strip().split()
            if len(elements) >= 2:  # Vérifie qu'il y a bien un budget et un nom
                try:
                    budget, nom = float(elements[0]), " ".join(elements[1:])
                    if nom == nom_utilisateur:  # Vérifier si c'est le bon utilisateur
                        budget1.append(budget)  # stocher juste les budget dans notre tableau
                except ValueError:
                    continue  # Ignore les lignes invalides

        if budget1:
            return max(budget1)  # Trouver le budget max
        return None  # Aucun budget trouvé pour l'utilisateur
    except FileNotFoundError:
        return None  # Si le fichier n'existe pas, retourner None

def sauvegarder_budget(budget):
    """Ajoute un budget au fichier et met à jour l'affichage."""
    try:
        fichier = open(FICHIER_BUDGET, "a")    # ouvrir en mode ajout
        fichier.write(f"{budget} {nom_utilisateur}\n")    # ecrire le budget et le nom de l'utilisateur 
        fichier.close()       # fermer le fichier
    except IOError:
        print("Erreur lors de l'écriture dans le fichier.")

def charger_tous_les_budgets():
    """Charge tous les budgets enregistrés et les trie du plus grand au plus petit."""
    budgets = []
    try:
        fichier = open(FICHIER_BUDGET, "r")
        lignes = fichier.readlines()
        fichier.close()

        for ligne in lignes:
            elements = ligne.strip().split()
            if len(elements) >= 2:
                try:
                    budget = float(elements[0])
                    budgets.append(budget)
                except ValueError:
                    continue  # Ignore les erreurs de conversion

        budgets.sort(reverse=True)  # Trier du plus grand au plus petit
        return budgets
    except FileNotFoundError:
        return []

def afficher_budget_et_record():
    """Affiche le budget et le record sur l'interface."""
    record = charger_record()
    lblBudgetRecord.config(text=f"Record : {record if record is not None else 'Aucun'} {nom_utilisateur}")

#--------------------------------------------------------------------------------
# Affichage du Classement 
#--------------------------------------------------------------------------------

def afficher_classement_final(budget_final):
    """Affiche un message de classement basé sur le budget final."""
    budgets = charger_tous_les_budgets()  # Charger tous les budgets classés

    if not budgets:  # Si aucun budget n'est enregistré
        message = "C'est votre premier budget enregistré !"
    elif budget_final == budgets[0]:  # Si c'est le record
        message = "🎉 Nouveau Record ! Félicitations ! 🎉"
    else:
        try:
            position = budgets.index(budget_final) + 1  # Trouver la position
            message = f"🏅 {position}ème Meilleur Budget !"
        except ValueError:
            message = "Budget non trouvé dans le classement."

    lblclassement.config(text=message)  # Mettre à jour l'affichage 
    
#----------------------------------------------------------------------------------------
# saisi des noms et affichage du graphique de l'évolution du budget en fonction du temps
#----------------------------------------------------------------------------------------

def utilisateur():
    """ fonction permettant de saisir le nom à chaque debut de partie"""
    global nom_utlisateur
    nom_utilisateur = entree_nom.get()  # Récupérer le nom entré par l'utilisateur
    if nom_utilisateur.strip():  # Vérifie si le champ n'est pas vide
        lblNom.config(text=f"Joueur : {nom_utilisateur}")  # Mettre à jour l'affichage
        root.deiconify()      # delencher l'ouverture la fenetre du menu afin de pouvoir lance la simalation ou consulter les tutoriels
        nom_window.destroy()  # Fermer la fenêtre
        
def enregistrer_budget_temps():
    """fonction qui permet d'enregister le budget en fonction du temps"""
    global budgetOM, budgetOP, duree_partie
    budgets_om.append(budgetOM) # stockage des differents budget de OM dans la liste budget_om
    budgets_op.append(budgetOP) # stockage des differents budget de OP dans la liste budget_op 
    temps.append(duree_partie)  # stockage du temps dans la liste duree_partie 

def afficher_graphe_final():
    """Fonction pour afficher le graphe à la fin de la partie"""
    plt.figure(figsize=(8, 6))
    plt.plot(temps, budgets_om, label="Budget OM", color='green')
    plt.plot(temps, budgets_op, label="Budget OP", color='red')
    plt.xlabel("Temps (s)")
    plt.ylabel("Budget")
    plt.title("Évolution du Budget pendant la Partie")
    plt.legend()
    plt.grid(True)
    plt.show()
    
#________________________________________________________________________________________      

def getCoordAleatoire(pTypesZones,pVoisinsEgalement=False,pBordure=0):
    """
Obj: Tirage aléatoire d'un emplacement d'un type parmi ceux la liste passé en argument
Les zones en bordure ne sont pas prises en compte
Arg : liste des types zones qui nous interessent
Retour : liste de 2 élements : Coordonnées (en matriciel et non en pixel)
    """

    dispo=False
    while (not dispo):
        i=random.randint(pBordure,len(matValCarteN1)-1-pBordure)
        j=random.randint(pBordure,len(matValCarteN1[0])-1-pBordure)
  
        if (pVoisinsEgalement):
            if(len(voisinsDisponibles(matValCarteN1,pTypesZones,j,i))==8):
                dispo=(matValCarteN1[j][i] in pTypesZones)
        else:
            dispo=(matValCarteN1[j][i] in pTypesZones)

    return [i,j]


"""
Obj : Recherche les coordonnées d'une zone unique et forcement présente
Arg : type de zone unique recherchée
Retour : Coordonnées trouvées
"""
def getCelluleZoneUnique(pTYPE_ZONE):
    dispo=False
    i=0
    j=0
    while (not dispo):
        if (matValCarteN1[j][i]==pTYPE_ZONE):
            dispo=True
        else:
            j+=1
            if j>=(len(matValCarteN1)):
                j=0
                i+=1            
                if i>=(len(matValCarteN1[0])):
                    dispo=True#Rien n'a été trouvé             

    return [i,j]

"""
Obj: Convertion des coordonnées réélles en coordonnées entières pour consulter la matrice
Permet ainsi de connaître le type d'item qui occupe la case occupé par le navire
Retour : liste de 2 élements : Coordonnées (en matriciel et non en pixel)

"""
def getCelluleEntiteMobile(pNoEntiteMobile):
    return [round(coord_iEntitesMobiles[pNoEntiteMobile]),round(coord_jEntitesMobiles[pNoEntiteMobile])]

"""
Obj: Convertir les indices de tableau en coordonnées pixel 
Paramètres : indices du tableau niveau
Retour : liste des 2 coordonnées en pixel 
"""
def getConvertCoordNiveauEnCoordPixels(i,j):
    x=LARG_CASE*i
    y=HAUT_CASE*j
    return [x,y]

"""
Obj: Convertir les coordonnées pixel en indices de tableau niveau
Paramètres : coordonnées pixel
Retour : liste des 2 indices du tableau matValCarteN1
"""
def getConvertCoordPixelsEnCoordNiveau(x,y):
    i=int(x/(LARG_CASE-(x%LARG_CASE)))
    j=int(y/(HAUT_CASE-(y%HAUT_CASE)))
    return [i,j]

"""
Obj: Convertir les coordonnées pixel en indices de tableau niveau
Paramètres : image et nouvelles coordonnées en pixel
"""
def deplacerImage(im,newX,newY):
    global gestionCanvas
    gestionCanvas.coords(im,newX,newY,
                         newX+LARG_CASE,newY+HAUT_CASE)


"""
Obj: Gestion des évènements du clavier

"""
def evenements(event):
    if event.keysym=="Up":
        pilotage(0,0,-VIT_MAX_OrgaMaritime)# demarrage(0,-VIT_MAX_OrgaMaritime)#,btnHaut)
    elif event.keysym=="Down":
        pilotage(0,0,VIT_MAX_OrgaMaritime)#,btnBas)
    elif event.keysym=="Left":
        pilotage(0,-VIT_MAX_OrgaMaritime,0)#,btnGauche)
    elif event.keysym=="Right":
        pilotage(0,VIT_MAX_OrgaMaritime,0)#,btnDroite)
    elif event.keysym == "n":
        suppression_des_nappes_hydocarbures()
    elif event.keysym == "v":
        ajout_de_nouvelles_zones_protegées()
    elif event.keysym == "p":
        deplacement_de_la_plateforme_petroliere()
        
    
    if event.keysym=="Escape":
        arret()
    elif event.keysym=="space":
        depart()

    

"""
Obj: Instanciation d'une nouvelle entité mobile (ex : navire, nappe hydrocarbure,etc..)
Param : Type d'entité mobile
"""
def creationEntiteMobile(pTypeEntiteMobile):
    global vitX,vitY,coord_iEntitesMobiles_Init,coord_jEntitesMobiles_Init,entitesMobiles
    global typesEntiteMobile,etats_chargement,gestionCanvas, posInitEntiteMobile
    
    if (pTypeEntiteMobile==TYPE_ORGA_MARITIME):
        posInitEntiteMobile=getCelluleZoneUnique(BM)#voisinsDisponibles(matValCarteN1,[ZT],getCelluleZoneUnique(BM)[0],getCelluleZoneUnique(BM)[1])[0]
    elif (pTypeEntiteMobile==TYPE_ORGA_PETROL):
        posInitEntiteMobile=getCelluleZoneUnique(BP)
    elif (pTypeEntiteMobile==TYPE_NAPPE_HYDRO):
        posInitEntiteMobile=getCelluleZoneUnique(PP)
    elif (pTypeEntiteMobile == NAVIRE_PIRATE):        # creation navire pirate 
        posInitEntiteMobile = getCoordAleatoire([ZN])  # Choisir une zone océanique
    coord_i_EntiteMobile=posInitEntiteMobile[0]
    coord_j_EntiteMobile=posInitEntiteMobile[1]
    coord_iEntitesMobiles_Init.append(coord_i_EntiteMobile)
    coord_jEntitesMobiles_Init.append(coord_j_EntiteMobile)
    coord_iEntitesMobiles.append(coord_i_EntiteMobile)
    coord_jEntitesMobiles.append(coord_j_EntiteMobile)

    vitX.append(0)
    vitY.append(0)
    
    coordPixel=getConvertCoordNiveauEnCoordPixels(posInitEntiteMobile[0],posInitEntiteMobile[1])
    
    #matValCarteN1[coord_j_EntiteMobile][coord_i_EntiteMobile]=pTypeEntiteMobile
    if (pTypeEntiteMobile==TYPE_ORGA_MARITIME):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgBateauOMempty,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    elif (pTypeEntiteMobile==TYPE_ORGA_PETROL):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgBateauOPempty,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    elif (pTypeEntiteMobile==TYPE_NAPPE_HYDRO):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgZH,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MAX)
    elif (pTypeEntiteMobile==NAVIRE_PIRATE):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgNAVIREPIRATE,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    
    typesEntiteMobile.append(pTypeEntiteMobile)

"""
Obj: Démarrage des déplacements des entités mobiles
Param :
    pVitesseX : Vitesse demandée par le joueur sur l'axe des abcisses
    pVitesseY : Vitesse demandée par le joueur sur l'axe des ordonnées
    pBtn : Bouton utilisé dont l'apparence doit mise à jour
"""
def pilotage(pNoEntiteMobile,pVitesseX,pVitesseY):
    global dde_arret,etat_actif_depl_anim,vitX,vitY
    
    if etat_actif_depl_anim == True:
        vitX[pNoEntiteMobile]=pVitesseX
        vitY[pNoEntiteMobile]=pVitesseY

"""
Obj: Appel récursif des déplacements de toutes les entités mobiles
Basculer la valeur de dde_arret à True pour stopper les déplacements
"""
def gestion_deplacements():

    global etat_actif_depl_anim, dde_arret,dureeSimulation
    global dureePP,dureeZP,imgCarteLigne,gestionCanvas #,noEntiteMobile
    
# pour arreter toutes les entites mobiles
    if (etat_actif_depl_anim):
        for noEntiteMobile in range(len(entitesMobiles)):
            deplacement(noEntiteMobile)#,typesEntiteMobile[i])
            if typesEntiteMobile[noEntiteMobile] == NAVIRE_PIRATE:
                chgtDirectionOP(noEntiteMobile)

        enregistrer_budget_temps()
        
        #Gestion des évolutions des zones PP et ZP
        dureePP-=tpsRafraichissement
        dureeZP-=tpsRafraichissement
        if (dureePP<0):#la PP a terminé son exploitation, une nouvelle doit être construite
            dureePP=dureePP_Initiale
            #déplacer la PP
            oldCoordPP=getCelluleZoneUnique(PP)
            newCoordPP=getCoordAleatoire([ZN],True,1)
            matValCarteN1[newCoordPP[1]][newCoordPP[0]]=PP
            matValCarteN1[oldCoordPP[1]][oldCoordPP[0]]=ZN
            gestionCanvas.itemconfig(matImgCarteN1[oldCoordPP[1]][oldCoordPP[0]],image = imgZN)
            gestionCanvas.itemconfig(matImgCarteN1[newCoordPP[1]][newCoordPP[0]],image = imgPP)
        if (dureeZP<0):#la ZP est suffisemment développée et une nouvelle peut être aménagée
            dureeZP=dureeZP_Initiale
            #déplacer la ZP
            newCoordZP=getCoordAleatoire([ZN],True,1)
            matValCarteN1[newCoordZP[1]][newCoordZP[0]]=ZP
            gestionCanvas.itemconfig(matImgCarteN1[newCoordZP[1]][newCoordZP[0]],image = imgZP)
    
    
    if dde_arret == False :#Tant que le simulateur ne doit pas être arrêté
        dureeSimulation+=tpsRafraichissement

        fen_princ.after(int(1000*tpsRafraichissement), gestion_deplacements)#Patienter 100ms afin d'appeler à nouveau cette même fonction (récursivité)
    else:
        dde_arret = False #Arrêt pris en compte et réinitialisé
        etat_actif_depl_anim = False #Animation désactivée
        
"""
Obj: Gestion de la logique de déplacement des ennemis
Param :
    pNoEntiteMobile : Identifiant du navire concerné
"""
def chgtDirectionOP(pNoEntiteMobile):
    global vitX, vitY, typesEntiteMobile
    
    if typesEntiteMobile[pNoEntiteMobile] == NAVIRE_PIRATE:
        direction = random.randint(1,100)
        if (direction<2):     #pour un changement de direction plus nette et normale
            # Mouvement aléatoire pour le navire pirate
            directions = [
                (VIT_MAX_NAVIRE_PIRATE, 0), (-VIT_MAX_NAVIRE_PIRATE, 0), 
                (0, VIT_MAX_NAVIRE_PIRATE), (0, -VIT_MAX_NAVIRE_PIRATE)
            ]
            vitX[pNoEntiteMobile], vitY[pNoEntiteMobile] = random.choice(directions)
    
    elif typesEntiteMobile[pNoEntiteMobile] == TYPE_ORGA_PETROL:
        # Comportement déjà existant pour l'OP
        if etats_chargement[pNoEntiteMobile] == ETAT_CHARGEMENT_MAX:
            coordCible = getCelluleZoneUnique(BP)
        else:
            coordCible = getCelluleZoneUnique(PP)

        vitX[pNoEntiteMobile], vitY[pNoEntiteMobile] = 0, 0

        if round(coord_iEntitesMobiles[pNoEntiteMobile]) > coordCible[0]:
            vitX[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
        elif round(coord_iEntitesMobiles[pNoEntiteMobile]) < coordCible[0]:
            vitX[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
        elif round(coord_jEntitesMobiles[pNoEntiteMobile]) > coordCible[1]:
            vitY[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
        elif round(coord_jEntitesMobiles[pNoEntiteMobile]) < coordCible[1]:
            vitY[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
    else:
         
        direction = random.randint(1,100)
     
        #if (vitX[pNoEntiteMobile]==0 and vitY[pNoEntiteMobile]==0): #Changement de direction si nous sommes à l'arrêt
        if direction <= 2 :#25% de chance qu'il parte à droite
            vitX[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
            vitY[pNoEntiteMobile] = 0

        elif direction <= 4 :#25% de chance qu'il parte à gauche
            vitX[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
            vitY[pNoEntiteMobile] = 0

        elif direction <= 6 :#25% de chance qu'il parte en bas
            vitX[pNoEntiteMobile] = 0
            vitY[pNoEntiteMobile] = VIT_MAX_OrgaPetrole

        elif direction <= 8:# de 75% et 100% inclus
            vitX[pNoEntiteMobile] = 0#25% de chance qu'il parte en haut
            vitY[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole


"""
Obj: Gestion des déplacements de chaque navire
Param :
    pNoEntiteMobile : Identifiant du navire concerné

"""
def deplacement(pNoEntiteMobile):
    global entitesMobiles, vitX, vitY,coord_iEntitesMobiles,typesEntiteMobile,etats_chargement,budgetOM,budgetOP
    
    if typesEntiteMobile[pNoEntiteMobile] == NAVIRE_PIRATE:
        if vitX[pNoEntiteMobile] == 0 and vitY[pNoEntiteMobile] == 0:  # S'il est immobile, forcer un changement
            chgtDirectionOP(pNoEntiteMobile)
        elif random.random() < 0.1:  # Sinon, il a 10% de chance de changer de direction
            chgtDirectionOP(pNoEntiteMobile)


    #Relancer les navires ennemis
    if (typesEntiteMobile[pNoEntiteMobile]!=TYPE_ORGA_MARITIME):
        chgtDirectionOP(pNoEntiteMobile)
    #2.2 Correction Naviguation OP--
    
    
    #Cas de changement d'axe de direction > Réaligner l'ancien
    if (vitX[pNoEntiteMobile]!=0):
        coord_jEntitesMobiles[pNoEntiteMobile]=round(coord_jEntitesMobiles[pNoEntiteMobile])
    else:#vitY!=0
        coord_iEntitesMobiles[pNoEntiteMobile]=round(coord_iEntitesMobiles[pNoEntiteMobile])
    
    #Incrémentation des coordonnées en fonction de la vitesse du navire
    coord_iEntitesMobiles[pNoEntiteMobile]+=vitX[pNoEntiteMobile]
    coord_jEntitesMobiles[pNoEntiteMobile]+=vitY[pNoEntiteMobile]    
    
    #identification des coordonnées de la cellule sur laquelle le navire s'engage 
    if (vitX[pNoEntiteMobile]>0 or vitY[pNoEntiteMobile]>0):
        coord_iEntiteMobile_matCarte=math.ceil(coord_iEntitesMobiles[pNoEntiteMobile])
        coord_jEntiteMobile_matCarte=math.ceil(coord_jEntitesMobiles[pNoEntiteMobile])
    else:
        coord_iEntiteMobile_matCarte=math.floor(coord_iEntitesMobiles[pNoEntiteMobile])
        coord_jEntiteMobile_matCarte=math.floor(coord_jEntitesMobiles[pNoEntiteMobile])
    
    #identification du type de décor présent sur cette cellule
    typeCarte=(matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte])
    
    if (typeCarte>=ZT):#Cas de collision avec des zones non naviguables
        #Repositionnement du navire
        if (vitX[pNoEntiteMobile]>0):
            coord_iEntitesMobiles[pNoEntiteMobile]=coord_iEntiteMobile_matCarte-1
        elif (vitX[pNoEntiteMobile]<0):
            coord_iEntitesMobiles[pNoEntiteMobile]=coord_iEntiteMobile_matCarte+1
        elif (vitY[pNoEntiteMobile]>0):
            coord_jEntitesMobiles[pNoEntiteMobile]=coord_jEntiteMobile_matCarte-1
        elif (vitY[pNoEntiteMobile]<0):
            coord_jEntitesMobiles[pNoEntiteMobile]=coord_jEntiteMobile_matCarte+1
        
        #Arrêt du navire
        vitX[pNoEntiteMobile]=0
        vitY[pNoEntiteMobile]=0
        
    #Cas de la nappe d'hydrocarbure arrivant dans une zone protégée
    elif (typeCarte==ZP and typesEntiteMobile[pNoEntiteMobile]==TYPE_NAPPE_HYDRO and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #Changer le statut de la cible
            matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte]=ZN
            #Modifier l'image
            gestionCanvas.itemconfig(matImgCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte], 
                                     image = imgZN)
            #mise à jour du budget            
            budgetOM=int(budgetOM)-tarifDEGAT
            lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
            #sauvegarder_budget(budgetOM) # pour la sauvegarde du budget de OM
            afficher_budget_et_record()
    #Cas de l'arrivée d'un navire de l'OM chargée à son port
    elif (typeCarte==BM and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #Déchargement du navire de l'OM
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MIN
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOMempty)
            #incrémentation du budget            
            budgetOM=int(budgetOM)+tarifTRAITEMENT
            lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
            #sauvegarder_budget(budgetOM)  # pour la sauvegarde du budget de OM
            afficher_budget_et_record()

    #Cas de l'arrivée d'un navire de l'OP vide à la plateforme pétrolière
    elif (typeCarte==PP and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_PETROL and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MIN):
            #Chargement du navire de l'OP
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MAX
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOPfull)
            creationEntiteMobile(TYPE_NAPPE_HYDRO)
    #Cas de l'arrivée d'un navire de l'OP chargée à son port
    elif (typeCarte==BP and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_PETROL and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #Déchargement du navire de l'OP
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MIN
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOPempty)
            #incrémentation du budget            
            budgetOP=int(budgetOP)+tarifVENTE
            lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
           # sauvegarder_budget(budgetOP)  # Sauvegarde OP
            afficher_budget_et_record()


    #Recherche de collision entre entites mobiles
    for a in range(0,len(entitesMobiles)):
        #Cas de l'interception de la nappe d'hydrocarbure a par le navire de l'OM pNoEntiteMobile
        if (typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME and typesEntiteMobile[a]==TYPE_NAPPE_HYDRO):
            if (getCelluleEntiteMobile(a)==getCelluleEntiteMobile(pNoEntiteMobile)):
                if (etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MIN and etats_chargement[a]==ETAT_CHARGEMENT_MAX):
                    #Changer le statut de la cible
                    matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte]=ZN
                    #Disparition de la nappe hydrocarbure
                    etats_chargement[a]=ETAT_CHARGEMENT_MIN
                    vitX[a]=0
                    vitY[a]=0
                    gestionCanvas.itemconfig(entitesMobiles[a],image = imgZN)
                    gestionCanvas.tag_lower(entitesMobiles[a])
                    budgetOP=int(budgetOP)-tarifSANCTION
                    lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
                    #Chargement du navire de l'OM
                    etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MAX
                    gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOMfull)
                    
    
        #cas de l'interception du navire OP par mon navire pirate 
        elif (typesEntiteMobile[pNoEntiteMobile]==NAVIRE_PIRATE and typesEntiteMobile[a]==TYPE_ORGA_PETROL):
            # Vérification si les deux navires sont dans la même cellule
            if (getCelluleEntiteMobile(a) == getCelluleEntiteMobile(pNoEntiteMobile)):
                # Vérification des états de chargement
                if (etats_chargement[a] == ETAT_CHARGEMENT_MAX):  # Le navire OP était chargé
                    etats_chargement[a] = ETAT_CHARGEMENT_MIN  # Il perd son chargement
                    gestionCanvas.itemconfig(entitesMobiles[a], image=imgBateauOPempty)  # Mise à jour de l'image
                    budgetOP -= tarifSANCTION  # Réduction du budget OP
                    lblBudgetOP.config(text=f"Budget OP : {budgetOP}")  # Mettre à jour l'affichage


    #Potentielle victoire et défaite
    if (typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME):
        (VictoireDefaite)()
        
        # pour mon bateau pirate 
    elif (typesEntiteMobile[pNoEntiteMobile]==NAVIRE_PIRATE):
        VictoireDefaite()
    
    #Repositonnement de l'image du navire en fonction de ses nouvelles coordonnées
    gestionCanvas.coords(entitesMobiles[pNoEntiteMobile],coord_iEntitesMobiles[pNoEntiteMobile]*LARG_CASE,coord_jEntitesMobiles[pNoEntiteMobile]*HAUT_CASE)

"""
Obj: Réinitiaisation toutes les positions et les vitesses et arrêt des animations et déplacements
"""
def depart():

    global vitX, vitY,typesEntiteMobile,dde_arret,etat_actif_depl_anim,budgetOM,budgetOP,etats_chargement
    global duree_partie, chrono_actif  # Ajout des variables globales
    
    #utilisateur()
    
    if (etat_actif_depl_anim==False):
        #Annulation de la vitesse en cours
        for i in range (len(vitX)):
            vitX[i]=0
        for i in range (len(vitY)):
            vitY[i]=0
    # Réinitialisation du temps uniquement si la partie n’a pas encore commencé
    if duree_partie == 0:
        duree_partie = 0
        lblDureePartie.config(text="Durée : 0s")  # Réinitialise l'affichage
    
    chrono_actif = True  # Active le chronomètre
    miseAJourDuree()  # Démarre le chrono
            
    for i in range(len(typesEntiteMobile)):
        if typesEntiteMobile[i] == NAVIRE_PIRATE:
            directions = [(VIT_MAX_NAVIRE_PIRATE, 0), (-VIT_MAX_NAVIRE_PIRATE, 0), (0, VIT_MAX_NAVIRE_PIRATE), (0, -VIT_MAX_NAVIRE_PIRATE)]
            vitX[i], vitY[i] = random.choice(directions)  # 🏴‍☠️ Donne une direction aléatoire

        
        #Réinitialisation des états de fonctionnement
        for i in range (len(etats_chargement)):
            if (typesEntiteMobile[i]==TYPE_NAPPE_HYDRO):
                etats_chargement[i]=ETAT_CHARGEMENT_MAX
            else:
                etats_chargement[i]=ETAT_CHARGEMENT_MIN
        #lblEtat.config(text = "Etat : "+str(etats_chargement[0])+"%")
    
        #Arrêt des animations et déplacement
        dde_arret = False
        etat_actif_depl_anim = True

        #2.1 Supression des Zones Nappes Hydro++
        nbNappesHydrocarbures=len(entitesMobiles)-(nbNavireOrgaMaritime+nbNavireOrgaPetroliere+nbNAVIREPIRATE)   #ajout de la variable nbNAVIREPIRATE pour la bon fonctionnement
        for i in range(nbNappesHydrocarbures):
            coord_iEntitesMobiles_Init.pop(-1)
            coord_jEntitesMobiles_Init.pop(-1)
            coord_iEntitesMobiles.pop(-1)
            coord_jEntitesMobiles.pop(-1)
            vitX.pop(-1)
            vitY.pop(-1)
            gestionCanvas.delete(entitesMobiles[-1])
            entitesMobiles.pop(-1)
         
        #2.1 Supression des Zones Nappes Hydro--
        #Repositionnement aux valeurs initiales        
        for noEntiteMobile in range(0,len(entitesMobiles)):  
            coord_iEntitesMobiles[noEntiteMobile]=coord_iEntitesMobiles_Init[noEntiteMobile]
            coord_jEntitesMobiles[noEntiteMobile]=coord_jEntitesMobiles_Init[noEntiteMobile]
            gestionCanvas.coords(entitesMobiles[noEntiteMobile],
                                 coord_iEntitesMobiles[noEntiteMobile]*LARG_CASE,
                                 coord_jEntitesMobiles[noEntiteMobile]*HAUT_CASE)
            if (typesEntiteMobile[noEntiteMobile]==TYPE_ORGA_MARITIME):
                gestionCanvas.itemconfig(entitesMobiles[noEntiteMobile],image = imgBateauOMempty)
            elif (typesEntiteMobile[noEntiteMobile]==TYPE_ORGA_PETROL):
                gestionCanvas.itemconfig(entitesMobiles[noEntiteMobile],image = imgBateauOPempty)
            # elif (typesEntiteMobile[noEntiteMobile]==NAVIRE_PIRATE):
            #     chgtDirectionOP(noEntiteMobile)
        
        #initialisation du budget            
        budgetOM=budgetOM_INIT
        budgetOP=budgetOP_INIT
        lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
        lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
        #initialisation de message de victoire & défaite
        lblMessage.config(text="")
        
        CreationImagesCarte()
        
        gestion_deplacements()
   


"""
Obj: Arrêt des animations et déplacements sans repositionner
"""
def arret():
    global dde_arret,etat_actif_depl_anim,chrono_actif
    if (etat_actif_depl_anim==True):
        #Mise à jour de la variale globale utilisée dans les déplacements
        dde_arret = True
        etat_actif_depl_anim=False
        chrono_actif = False  # Stopper le chronomètre
        sauvegarder_budget(budgetOM)    


"""
Obj: Verification des conditions de Victoire et de Défaite
Dans le cas de victoire comme de défaite, le simulateur sera arrêté et un message mis à jour
"""
def VictoireDefaite():
    global matValCarteN1
    nbZonesDisponibles=0
    for i in range(len(matValCarteN1)):
        for j in range(len(matValCarteN1[i])):
            if (matValCarteN1[j][i]==ZN and (len(voisinsDisponibles(matValCarteN1,[ZN],j,i))==8)):
                nbZonesDisponibles+=1
    if (nbZonesDisponibles==0) or budgetOP < 0 :#Aucune zone disponible ajout ;
        arret()
        lblMessage.config(text="Victoire",fg='#0f0')
        # ajout pour mon chronometre
        chrono_actif = False  # Arrêter le chrono
        afficher_classement_final(budgetOM)  # Si budgetOM est le budget final
        afficher_graphe_final()
        
    elif budgetOM<0:    
        arret()
        lblMessage.config(text="Défaite",fg='#f00')
        chrono_actif = False  # Arrêter le chrono
        afficher_classement_final(budgetOM)  # Si budgetOM est le budget final
        afficher_graphe_final()


"""
Obj: Créer ou Recréer les images du décor
"""
def CreationImagesCarte():
    global matValCarteN1,matImgCarteN1
    
    #Suppression de toutes les images de décor déjà présentes (cas de redémarrage)
    for imgCarteLigne in matImgCarteN1:
        for j in imgCarteLigne:
            gestionCanvas.delete(j)
    matImgCarteN1.clear()
    
    #réinitialisation des valeurs de la matrice
    matValCarteN1=np.copy(matValCarteN1_initial)
    
    #Création
    for i in range(len(matValCarteN1)):
        imgCarteLigne=[]
        for j in range(len(matValCarteN1[i])):
            if (matValCarteN1[i][j]==ZN):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZN,anchor=NW))
            elif (matValCarteN1[i][j]==ZP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZP,anchor=NW))
            elif (matValCarteN1[i][j]==ZT):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZT,anchor=NW))
            elif (matValCarteN1[i][j]==BP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgBP,anchor=NW))
            elif (matValCarteN1[i][j]==PP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgPP,anchor=NW))
            elif (matValCarteN1[i][j]==BM):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgBM,anchor=NW))    
            elif (matValCarteN1[i][j]==CG):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCG,anchor=NW))
            elif (matValCarteN1[i][j]==CD):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCD,anchor=NW))
            elif (matValCarteN1[i][j]==CDh):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCDh,anchor=NW))
            elif (matValCarteN1[i][j]==CGh):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCGh,anchor=NW))
            elif (matValCarteN1[i][j]==CH):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCH,anchor=NW))
            elif (matValCarteN1[i][j]==CB):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCB,anchor=NW))
            elif (matValCarteN1[i][j]==cG):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgcG,anchor=NW))
            elif (matValCarteN1[i][j]==cD):  
                 imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgcD,anchor=NW))
            gestionCanvas.tag_lower(imgCarteLigne[-1])#v0.5
        matImgCarteN1.append(imgCarteLigne)
        
def voisinsDisponibles(pLaby,pValsDisponibles,pX,pY):

    voisinsDisponibles=[]
    # voisins connexite 8
    voisins=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,1],[-1,-1],[1,-1]]
    for v in voisins:
        # coordonnees du voisin
        voisinX=pX+v[0]
        voisinY=pY+v[1]
        if pLaby[voisinX][voisinY] in pValsDisponibles:
            voisinsDisponibles.append([voisinX,voisinY])
            
    return voisinsDisponibles
    
# ----------------------------------------------------------------
# Corps du programme
# ----------------------------------------------------------------

#Paramétrage de la fenêtre principale
fen_princ = Tk()
fen_princ.title("OCEAN WAR L1 SPI")
fen_princ.geometry("900x700")#Dimensions de la fenêtre
fen_princ.bind("<Key>",evenements)#Définition de la fonction de gestion des évènements clavier
fen_princ.withdraw()   # masquer la fenetre et n'apparaitre qu'apres aoir lancé la simulation 

#Paramétrage du Canvas
gestionCanvas = Canvas(fen_princ, width=LARG_CANVAS, height=HAUT_CANVAS, bg='ivory', bd=0, highlightthickness=0)
gestionCanvas.grid(row=0,column=0, padx=10,pady=10)

#Affichage des différents types de zone
imgZN=PhotoImage(file = ("img/ocean40.gif"),master=fen_princ)
imgZP=PhotoImage(file = ("img/protection40.gif"),master=fen_princ)
imgZT=PhotoImage(file = ("img/terrainCC40.gif"),master=fen_princ)
imgBP=PhotoImage(file = ("img/port40red.gif"),master=fen_princ)
imgPP=PhotoImage(file = ("img/platform40.gif"),master=fen_princ)
imgBM=PhotoImage(file = ("img/port40green.gif"),master=fen_princ)
imgCG=PhotoImage(file = ("img/terrainHG40.gif"),master=fen_princ) #image pour la cote gauche 
imgCD=PhotoImage(file = ("img/terrainHD40.gif"),master=fen_princ) #image pour le cote droit
imgCGh=PhotoImage(file = ("img/terrainBG40.gif"),master=fen_princ) #image pour le coin gauche bas
imgCDh=PhotoImage(file = ("img/terrainBD40.gif"),master=fen_princ) #image pour le coin droite bas
imgCH=PhotoImage(file = ("img/terrainCH40.gif"),master=fen_princ) #image pour le cote haut
imgCB=PhotoImage(file = ("img/terrainCB40.gif"),master=fen_princ) #image pour le cote bas
imgcG=PhotoImage(file = ("img/terrainCG40.gif"),master=fen_princ) #image pour le coin gauche haut
imgcD=PhotoImage(file = ("img/terrainCD40.gif"),master=fen_princ) #image pour le coin droite haut
matImgCarteN1 = []

#Création et positionnement des images du décor en fonction des valeurs de matValCarteN1
CreationImagesCarte()

#Images utilisées pour l'affichage des navires
imgBateauOMfull=PhotoImage(file = ("img/bateauOMI40full.gif"),master=fen_princ)
imgBateauOMempty=PhotoImage(file = ("img/bateauOMI40empty.gif"),master=fen_princ)
imgZH=PhotoImage(file = ("img/hydrocarbure40a.gif"),master=fen_princ)
imgBateauOPfull=PhotoImage(file = ("img/bateauOPEP40full.gif"),master=fen_princ)
imgBateauOPempty=PhotoImage(file = ("img/bateauOPEP40empty.gif"),master=fen_princ)
imgNAVIREPIRATE=PhotoImage(file = ("img/ecoboat40.gif"),master=fen_princ)  #image pour mon navire pirate

#Création des navires de l'OMI
nbNavireOrgaMaritime=1
for i in range(nbNavireOrgaMaritime):
    creationEntiteMobile(TYPE_ORGA_MARITIME)
    
#creation de mon navire pirate 
nbNAVIREPIRATE=5        
for i in range(nbNAVIREPIRATE):
    creationEntiteMobile(NAVIRE_PIRATE)

#Création des navires de l'OP
nbNavireOrgaPetroliere=1
for i in range(nbNavireOrgaPetroliere):
    creationEntiteMobile(TYPE_ORGA_PETROL)

#Création des nappes hydrocarbures 
nbNappesHydrocarbures=1
for i in range(nbNappesHydrocarbures):
    creationEntiteMobile(TYPE_NAPPE_HYDRO)



#Zone dédiée aux boutons
zoneBtn = Frame(fen_princ)
zoneBtn.grid(row=0,column=1,ipadx=5)
  
#Boutons d'arrêt et de réinitialisation
lblMessage = Label(zoneBtn, text="")
Font_tuple = ("Comic Sans MS", 20, "bold")  
lblMessage.configure(font = Font_tuple) 
lblMessage.pack(fill=X)

lblBudgetOM = Label(zoneBtn, text="Budget OM")
lblBudgetOM.pack(fill=X)
lblBudgetOP = Label(zoneBtn, text="Budget OP")
lblBudgetOP.pack(fill=X)
btnArret = Button(zoneBtn, text="STOP", fg="yellow", bg="red", command=arret)
btnArret.pack(fill=X)
btnInit = Button(zoneBtn, text="START", fg="yellow", bg="green", command=depart)
btnInit.pack(fill=X)

#-----------------------------------------------------------------------------------------------------
# L'afficahge de mon record, du classement du record, du chronometre et le nom lié au record
#-----------------------------------------------------------------------------------------------------

# affichage du record
lblBudgetRecord = Label(zoneBtn, text="Record : 0", fg="blue", bg="yellow", font=("calibri", 15))
lblBudgetRecord.pack(fill=X)
lblclassement = Label(zoneBtn, text="", fg="blue",bg="yellow", font=("century gothic", 15))
lblclassement.pack(fill=X)

# mise a jour du buget et du record
afficher_budget_et_record()   # Met à jour l'affichage

# creation du widget pour mon chronometre
lblDureePartie = Label(zoneBtn, text="Durée : 0s",fg="blue", bg="yellow",font=("calibri", 15))  # Affichage du temps
lblDureePartie.pack(fill=X)

# affichage du nom lié au record à l'interface 
lblNom = Label(zoneBtn, text=f"nom_utilisateur", fg="red",font=("Comic Sans MS", 15))



#----------------------------------------------------------------------------------
# Création la fenêtre du Menu principal
#----------------------------------------------------------------------------------
root = tk.Tk()
root.title("Eco-Guerrier - Menu Principal")
root.geometry("700x600")
root.withdraw()

# Titre du menu
titre = tk.Label(root, text="Eco-Guerrier", font=("calibri", 24, "bold"))
titre.pack(pady=40)

# Bouton pour afficher le tutoriel
btn_tutoriel = tk.Button(root, text="Consulter le tutoriel", command=afficher_tutoriel,font=("calibri", 14), bg="red", fg="yellow")
btn_tutoriel.pack(pady=20)


# Bouton pour lancer la simulation 
btn_lancer = tk.Button(root, text="lancer la simulation", command=lancerSimulation, font=("calibri", 14), bg="blue", fg="yellow")
btn_lancer.pack(pady=40)

# Bouton pour quitter
btn_quitter = tk.Button(root, text="Quitter", command=root.destroy, font=("calibri", 14), bg="yellow", fg="red")
btn_quitter.pack(pady=40)

#---------------------------------------------------------------------------------
# Création de la fenêtre pour l'insertion du nom
#---------------------------------------------------------------------------------

nom_window = tk.Toplevel(root)
nom_window.title("Nom du Guerrier")
nom_window.geometry("400x200")

# Texte d'instruction
tk.Label(nom_window, text="Saisissez votre nom pour commencer le jeu :", font=("calibri", 12)).pack(pady=10)

# Champ de saisie
entree_nom = tk.Entry(nom_window, font=("Arial", 12))
entree_nom.pack(pady=5)

# Bouton de validation
btn_valider = tk.Button(nom_window, text="Valider", command=utilisateur, font=("calibri", 12),bg="yellow", fg="red")
btn_valider.pack(pady=10)
#---------------------------------------------------------------------------------------------------------------

# Lancer l'interface du menu principal
root.mainloop()

#Rafraichissement de la fenêtre et de tout son contenu
fen_princ.mainloop()
          </code></pre>
        </details>

        <p>
          🔽 <a href="ProjetL1Algo25_v02.py" download>Télécharger le script Python</a><br>
          🔗 <a href="https://github.com/tonpseudo/eco-guerrier" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>

      <li>
        <strong>Projet 2 : Simulateur Banque</strong><br>
        <p>Une application en Python avec interface graphique Tkinter permettant :</p>
        <ul>
          <li>la création de comptes bancaires</li>
          <li>la consultation de soldes</li>
          <li>le dépôt et le retrait d'argent</li>
          <li>le transfert d'argent entre comptes</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Projet : Simulateur Banque
@author: NADAL NGAKI MUPATI
"""
import tkinter as tk
FICHIER = "compte.txt"
            
# --- Fonctions de lecture/écriture du fichier ---

def lire_compte():
    comptes = []
    try:
        with open(FICHIER, 'r') as f:
            for ligne in f:
                ligne = ligne.strip()
                if ligne:
                    nom, solde = ligne.split(',')
                    comptes.append((nom, float(solde)))
    except FileNotFoundError:
        pass
    return comptes

def ecrire_compte(comptes):
    with open(FICHIER, 'w') as f:
        for nom, solde in comptes:
            f.write(f"{nom},{solde}\n")

# --- Création d'un compte avec fenêtre secondaire ---

def creer_compte():
    def valider_creation():
        nom = entre_nom.get().strip()
        if not nom:
            label_result.config(text="❌ Nom invalide.")
            return

        comptes = lire_compte()
        for n, _ in comptes:
            if n == nom:
                label_result.config(text="❌ Ce nom a déjà un compte.")
                fenetre_creation.destroy()
                return

        comptes.append((nom, 0.0))
        ecrire_compte(comptes)
        label_result.config(text=f"✅ Compte créé pour {nom} avec un solde de 0 €.")
        fenetre_creation.destroy()

    # Fenêtre secondaire
    fenetre_creation = tk.Toplevel(root)
    fenetre_creation.title("Création d'un compte")
    fenetre_creation.geometry("400x200")

    label_info = tk.Label(fenetre_creation, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info.pack(pady=10)

    entre_nom = tk.Entry(fenetre_creation, width=30)
    entre_nom.pack(pady=5)

    bouton_valider = tk.Button(fenetre_creation, text="Valider", command=valider_creation)
    bouton_valider.pack(pady=10)

# --- Voir le solde ---

def voir_solde():
    def valider_solde():
        nom = entre_nom1.get().strip()
        comptes = lire_compte()
    
        for n, solde in comptes:
            if n == nom:
                label_result.config(text=f"💰 Solde de {nom} : {solde} €")
                fenetre_creation1.destroy()
                return
        label_result.config(text="❌ Compte introuvable.")
        fenetre_creation1.destroy()
        
        
    fenetre_creation1 = tk.Toplevel(root)
    fenetre_creation1.title("verification de solde")
    fenetre_creation1.geometry("400x200")

    label_info1 = tk.Label(fenetre_creation1, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info1.pack(pady=10)

    entre_nom1 = tk.Entry(fenetre_creation1, width=30)
    entre_nom1.pack(pady=5)
    
    bouton_valider1 = tk.Button(fenetre_creation1, text="Valider", command=valider_solde)
    bouton_valider1.pack(pady=10)

# --- Dépôt d'argent ---

def faire_un_depot():
    def valider_depot():
        
        nom = entre_nom2.get().strip()
        try:
            montant = float(entre_montant2.get())
        except ValueError:
            label_result.config(text="❌ Montant invalide.")
            fenetre_creation2.destroy()
            return
    
        comptes = lire_compte()
        for i, (n, solde) in enumerate(comptes):
            if n == nom:
                comptes[i] = (n, solde + montant)
                ecrire_compte(comptes)
                label_result.config(text=f"✅ {montant} € déposés. Nouveau solde : {solde + montant} €")
                fenetre_creation2.destroy()
                return
                
        label_result.config(text="❌ Compte introuvable.")
        fenetre_creation2.destroy()
        
    fenetre_creation2 = tk.Toplevel(root)
    fenetre_creation2.title("faire un depot")
    fenetre_creation2.geometry("400x200")

    label_info2 = tk.Label(fenetre_creation2, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info2.pack(pady=10)
    entre_nom2 = tk.Entry(fenetre_creation2, width=30)
    entre_nom2.pack(pady=5)
    
    label_montant2 = tk.Label(fenetre_creation2, text="Saisir le montant :", font=("Arial", 12))
    label_montant2.pack(pady=10)
    entre_montant2 = tk.Entry(fenetre_creation2, width=30)
    entre_montant2.pack(pady=5)
    
    bouton_valider2 = tk.Button(fenetre_creation2, text="Valider", command=valider_depot)
    bouton_valider2.pack(pady=10)
    

# --- Retrait d'argent ---

def faire_un_retrait():
    def valider_retrait():
        nom = entre_nom3.get().strip()
        try:
            montant = float(entre_montant3.get())
        except ValueError:
            label_result.config(text="❌ Montant invalide.")
            return
    
        comptes = lire_compte()
        for i, (n, solde) in enumerate(comptes):
            if n == nom:
                if solde >= montant:
                    comptes[i] = (n, solde - montant)
                    ecrire_compte(comptes)
                    label_result.config(text=f"✅ {montant} € retirés. Nouveau solde : {solde - montant} €")
                else:
                    label_result.config(text="❌ Fonds insuffisants.")
                    fenetre_creation3.destroy()
                return
        label_result.config(text="❌ Compte introuvable.")
        fenetre_creation3.destroy()
        
    
    fenetre_creation3 = tk.Toplevel(root)
    fenetre_creation3.title("faire un retrait")
    fenetre_creation3.geometry("400x200")

    label_info3 = tk.Label(fenetre_creation3, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info3.pack(pady=10)
    entre_nom3 = tk.Entry(fenetre_creation3, width=30)
    entre_nom3.pack(pady=5)
    
    label_montant3 = tk.Label(fenetre_creation3, text="Saisir le montant :", font=("Arial", 12))
    label_montant3.pack(pady=10)
    entre_montant3 = tk.Entry(fenetre_creation3, width=30)
    entre_montant3.pack(pady=5)
    
    bouton_valider3 = tk.Button(fenetre_creation3, text="Valider", command=valider_retrait)
    bouton_valider3.pack(pady=10)

# --- transfert d'argent ---
    
def faire_un_transfert():
    def valider_transfert():
        expediteur = entre_nom5.get().strip()
        destinataire = entre_nom6.get().strip()
        try:
            montant = float(entre_montant6.get())
        except ValueError:
            label_result.config(text="❌ Montant invalide.")
            fenetre_transfert.destroy()
            return

        comptes = lire_compte()
        index_expediteur = index_destinataire = -1

        for i, (nom, solde) in enumerate(comptes):
            if nom == expediteur:
                index_expediteur = i
            if nom == destinataire:
                index_destinataire = i

        if index_expediteur == -1:
            label_result.config(text="❌ Compte expéditeur introuvable.")
        elif index_destinataire == -1:
            label_result.config(text="❌ Compte destinataire introuvable.")
        elif comptes[index_expediteur][1] < montant:
            label_result.config(text="❌ Fonds insuffisants.")
        else:
            comptes[index_expediteur] = (expediteur, comptes[index_expediteur][1] - montant)
            comptes[index_destinataire] = (destinataire, comptes[index_destinataire][1] + montant)
            ecrire_compte(comptes)
            label_result.config(text=f"✅ Transfert de {montant} € de {expediteur} à {destinataire} réussi.")

        fenetre_transfert.destroy()

    # Fenêtre de transfert
    fenetre_transfert = tk.Toplevel(root)
    fenetre_transfert.title("Faire un transfert")
    fenetre_transfert.geometry("400x300")

    label_info5 = tk.Label(fenetre_transfert, text="Nom de l'expéditeur :", font=("Arial", 12))
    label_info5.pack(pady=5)
    entre_nom5 = tk.Entry(fenetre_transfert, width=30)
    entre_nom5.pack(pady=5)

    label_info6 = tk.Label(fenetre_transfert, text="Nom du bénéficiaire :", font=("Arial", 12))
    label_info6.pack(pady=5)
    entre_nom6 = tk.Entry(fenetre_transfert, width=30)
    entre_nom6.pack(pady=5)

    label_montant6 = tk.Label(fenetre_transfert, text="Montant à transférer :", font=("Arial", 12))
    label_montant6.pack(pady=5)
    entre_montant6 = tk.Entry(fenetre_transfert, width=30)
    entre_montant6.pack(pady=5)

    bouton_valider6 = tk.Button(fenetre_transfert, text="Valider", command=valider_transfert)
    bouton_valider6.pack(pady=10)

        

# --- Interface graphique principale ---

root = tk.Tk()
root.title("BANQUE FRANCE-AFRIQUE")
root.geometry("700x650")
root.configure(bg="#DDEEFF")

texte_accueil = (
    "Bienvenue dans votre espace client !\n\n"
    "Voici les opérations disponibles :\n"
    "1 - Créer un compte : enregistrez un nouveau nom (solde initial = 0 €)\n"
    "2 - Voir le solde : consultez votre solde actuel\n"
    "3 - Faire un dépôt : ajoutez de l’argent sur votre compte\n"
    "4 - Faire un retrait : retirez de l’argent (si solde suffisant)\n"
    "5 - faire un transfert : envoyez de l'argent à un autre compte\n"
    "6 - Quitter\n"
)
label_intro = tk.Label(root, text=texte_accueil, justify="left", font=("calibri", 14), fg="red", wraplength=600)
label_intro.pack(pady=10)


label_result = tk.Label(root, text="", font=("arial", 14), fg="blue")
label_result.pack(pady=10)

frame_boutons = tk.Frame(root)
frame_boutons.pack(pady=10)

btn_creer = tk.Button(frame_boutons, text="1. Créer un compte", width=30, command=creer_compte)
btn_creer.grid(row=0, column=0, pady=5)

btn_solde = tk.Button(frame_boutons, text="2. Voir le solde", width=30, command=voir_solde)
btn_solde.grid(row=1, column=0, pady=5)

btn_depot = tk.Button(frame_boutons, text="3. Faire un dépôt", width=30, command=faire_un_depot)
btn_depot.grid(row=2, column=0, pady=5)

btn_retrait = tk.Button(frame_boutons, text="4. Faire un retrait", width=30, command=faire_un_retrait)
btn_retrait.grid(row=3, column=0, pady=5)

btn_transfert = tk.Button(frame_boutons, text="5. Faire un transfert", width=30, command=faire_un_transfert)
btn_transfert.grid(row=3, column=0, pady=5)

btn_quitter = tk.Button(frame_boutons, text="6. Quitter", width=30, command=root.destroy)
btn_quitter.grid(row=4, column=0, pady=10)

root.mainloop()
          </code></pre>
        </details>

        <p>
          🔽 <a href="PROJET1_BANQUE.py" download>Télécharger le script Python</a><br>
          🔗 <a href="https://github.com/nadal243/banque-simulateur" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>
    
      <li>
        <strong>Projet 3 : Visualiseur de Données CSV/Excel</strong><br>
        <p>
          Une application Python avec interface Tkinter permettant de visualiser graphiquement des données provenant de fichiers CSV ou Excel.
        </p>
        <ul>
          <li>Chargement dynamique de fichiers .csv ou .xlsx</li>
          <li>Sélection des colonnes X et Y</li>
          <li>Types de graphiques : courbes, barres, nuages de points, histogrammes</li>
          <li>Fonction zoom/dézoom et réinitialisation</li>
          <li>Export du graphique en PNG</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Created on Fri May 30 15:24:08 2025

@author: NADAL NGAKI MUPATI
"""

# Importation des bibliothèques nécessaires pour l'interface graphique, le traitement de données et la visualisation
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import os 

class VisualiseurCSV:
    def __init__(self, root):
        self.root = root
        self.root.title("Visualiseur des données CSV")
        self.root.geometry("1000x750")

        self.df = None
        self.canvas = None
        
        # Créer deux frames pour séparer les contrôles (gauche) et le graphique (droite)
        # Zone de gauche : contient les boutons et menus
        self.frame_gauche = tk.Frame(self.root)
        # Zone de droite : affichera le graphique
        self.frame_droite = tk.Frame(self.root)
        # Zone de gauche : contient les boutons et menus
        self.frame_gauche.pack(side=tk.LEFT, padx=20, pady=20, anchor='n')
        # Zone de droite : affichera le graphique
        self.frame_droite.pack(side=tk.LEFT, padx=20, pady=20, anchor='n')

        # -------- Interface utilisateur : affichage d'instructions --------
        label_info = tk.Label(
            self.frame_gauche,
            text="Bienvenue dans le visualiseur de données\n\n"
                 "1. Importez un fichier CSV ou Excel\n"
                 "2. Choisissez les colonnes X et Y\n"
                 "3. Choisissez le type de graphique\n"
                 "4. Cliquez sur 'Tracer le graphique'",
            justify="left",
            font=("Calibri", 12)
        )
        label_info.pack(pady=10)
        
        

        # Bouton pour charger un fichier CSV
        self.btn_charger = tk.Button(self.frame_gauche, text="Charger un fichier", command=self.charger_csv)
        self.btn_charger.pack(pady=10)

        # Combobox pour sélectionner les colonnes X et Y à partir des données
        self.colonne_x = ttk.Combobox(self.frame_gauche, state='readonly')
        self.colonne_y = ttk.Combobox(self.frame_gauche, state='readonly')
        self.colonne_x.pack(pady=5)
        self.colonne_y.pack(pady=5)
        
        # Sélection du type de graphique
        label_info = tk.Label(self.frame_gauche, text="selectionnez le type de graphique:", font=("calibri", 12))
        label_info.pack(pady=5)
        
        self.type_graphique = ttk.Combobox(self.frame_gauche, state='readonly')
        self.type_graphique['values'] = ['Ligne', 'Nuage de points', 'Barres', 'Histogramme']
        self.type_graphique.current(0)
        self.type_graphique.pack(pady=5)

        # Bouton pour tracer le graphique
        self.btn_tracer = tk.Button(self.frame_gauche, text="Tracer le graphique", command=self.tracer_graphique)
        self.btn_tracer.pack(pady=10)
        
        # Boutons de zoom
        self.btn_zoom_in = tk.Button(self.frame_gauche, text="Zoomer", command=self.zoom_in)
        self.btn_zoom_out = tk.Button(self.frame_gauche, text="Dézoomer", command=self.zoom_out)
        self.btn_reset_zoom = tk.Button(self.frame_gauche, text="Réinitialiser le zoom", command=self.reset_zoom)
        
        self.btn_zoom_in.pack(pady=5)
        self.btn_zoom_out.pack(pady=5)
        self.btn_reset_zoom.pack(pady=5)
        
        # Bouton pour sauvegarder le graphique
        self.btn_sauvegarder = tk.Button(self.frame_gauche, text="sauvegarder le graphique", command=self.SauvegaderGraphique)
        self.btn_sauvegarder.pack(pady=5)
        
        # Bouton pour supprimer le graphique
        self.btn_supprimer = tk.Button(self.frame_gauche, text="supprimer le graphique", command=self.supprimer_graphique)
        self.btn_supprimer.pack(pady=5)

    def charger_csv(self):
        # -------- Chargement du fichier CSV et extraction des colonnes --------
        chemin = filedialog.askopenfilename(
            filetypes=[
                ("Fichiers CSV et Excel", "*.csv *.xls *.xlsx"),
                ("Fichiers CSV", "*.csv"),
                ("Fichiers Excel", "*.xls *.xlsx")])
        if chemin:
            try:
                ext = os.path.splitext(chemin)[1].lower()
                if ext == ".csv":
                    self.df = pd.read_csv(chemin)
                elif ext in [".xls", ".xlsx"]:
                    self.df = pd.read_excel(chemin)
                else:
                    messagebox.showerror("Erreur, Format de fichier non pris en charge.")
                colonnes = list(self.df.columns)
                self.colonne_x['values'] = colonnes
                self.colonne_y['values'] = colonnes
                messagebox.showinfo("Succès", "Fichier chargé avec succès.")
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible de lire le fichier :\n{e}")

    def tracer_graphique(self):
        # -------- Vérification des conditions minimales --------
        if self.df is None:
            messagebox.showwarning("Attention", "Aucun fichier chargé.")
            return

        x_col = self.colonne_x.get()
        y_col = self.colonne_y.get()
        type_graph = self.type_graphique.get()

        if not x_col or not y_col:
            messagebox.showwarning("Attention", "Veuillez sélectionner les colonnes X et Y.")
            return

        try:
            # -------- Nettoyage des données : conversion en numérique et suppression des valeurs manquantes --------
            self.df[x_col] = pd.to_numeric(self.df[x_col], errors='coerce')
            self.df[y_col] = pd.to_numeric(self.df[y_col], errors='coerce')
            self.df.dropna(subset=[x_col, y_col], inplace=True)

            fig, ax = plt.subplots(figsize=(6, 4))
            self.ax = ax 

            # -------- Tracé du graphique selon le type sélectionné --------
            if type_graph == 'Ligne':
                ax.plot(self.df[x_col], self.df[y_col], marker='o')  # Graphique en ligne
            elif type_graph == 'Nuage de points':
                ax.scatter(self.df[x_col], self.df[y_col])           # Nuage de points
            elif type_graph == 'Barres':
                ax.bar(self.df[x_col], self.df[y_col])              # Diagramme en barres
            elif type_graph == 'Histogramme':
                ax.hist(self.df[y_col], bins=20, edgecolor='black') # Histogramme simple
                ax.set_xlabel(y_col)
                ax.set_ylabel("Fréquence")
                ax.set_title(f"Histogramme de {y_col}")
                ax.grid(True)
            else:
                messagebox.showwarning("Erreur", "Type de graphique non reconnu.")
                return

            # -------- Paramétrage général pour les autres types --------
            if type_graph != 'Histogramme':
                ax.set_xlabel(x_col)
                ax.set_ylabel(y_col)
                ax.set_title(f"{y_col} en fonction de {x_col}")
                ax.grid(True)

            # Suppression de l'ancien graphique si présent
            if self.canvas:
                self.canvas.get_tk_widget().destroy()

            # Affichage du graphique dans l’interface Tkinter
            self.canvas = FigureCanvasTkAgg(fig, master=self.frame_droite)
            self.canvas.draw()
            self.canvas.get_tk_widget().pack(pady=10)
            
            # FORCER le rendu puis sauvegarder les limites d'origine
            fig.canvas.draw()  # Très important
            self.original_xlim = self.ax.get_xlim()
            self.original_ylim = self.ax.get_ylim()
            
            # -------- Sauvegarde temporaire de la figure pour la fonction de sauvegarde --------
            self.current_fig = fig

        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors du tracé :\n{e}")
                
    def SauvegaderGraphique(self):
        # -------- Sauvegarde du graphique affiché en tant qu’image PNG --------
        if hasattr(self, 'current_fig'):
            fichier = filedialog.asksaveasfilename(defaultextension='.png',
                                                   filetypes=[("Fichier PNG", "*.png")])
            if fichier:
                try:
                    self.current_fig.savefig(fichier)
                    messagebox.showinfo("Succès", "Graphique sauvegardé avec succès.")
                except Exception as e:
                    messagebox.showerror("Erreur", f"Impossible de sauvegarder le graphique :\n{e}")
        else:
            messagebox.showwarning("Avertissement", "Aucun graphique à sauvegarder.")
            
    def zoom_in(self):
        if self.ax:
            xlim = self.ax.get_xlim()
            ylim = self.ax.get_ylim()
            self.ax.set_xlim([xlim[0] + (xlim[1] - xlim[0]) * 0.1, xlim[1] - (xlim[1] - xlim[0]) * 0.1])
            self.ax.set_ylim([ylim[0] + (ylim[1] - ylim[0]) * 0.1, ylim[1] - (ylim[1] - ylim[0]) * 0.1])
            self.canvas.draw()

    def zoom_out(self):
        if self.ax:
            xlim = self.ax.get_xlim()
            ylim = self.ax.get_ylim()
            self.ax.set_xlim([xlim[0] - (xlim[1] - xlim[0]) * 0.1, xlim[1] + (xlim[1] - xlim[0]) * 0.1])
            self.ax.set_ylim([ylim[0] - (ylim[1] - ylim[0]) * 0.1, ylim[1] + (ylim[1] - ylim[0]) * 0.1])
            self.canvas.draw()
    
    def reset_zoom(self):
        if self.ax:
            if hasattr(self, 'original_xlim') and hasattr(self, 'original_ylim'):
                self.ax.set_xlim(self.original_xlim)
                self.ax.set_ylim(self.original_ylim)
            else:
                self.ax.relim()
                self.ax.autoscale_view()
            self.canvas.draw()
    
    def supprimer_graphique(self):
    #-----------permet d'effacer le graphique--------
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None
            self.ax = None
            if hasattr(self, 'original_xlim'):
                del self.original_xlim
            if hasattr(self, 'original_ylim'):
                del self.original_ylim

# -------- Lancement de l'application --------
if __name__ == "__main__":
    root = tk.Tk()
    app = VisualiseurCSV(root)
    root.mainloop()

          </code></pre>
        </details>

        <p>
          🔽 <a href="PROJET_visualiseur des données.py" download>Télécharger le script Python</a><br>
          🔗 <a href="https://github.com/nadal243/visualiseur-csv-excel" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>
</ul>
  </section

      
      <li>
        <strong>Projet 4 : Vidéo surveillance</strong><br>
        <p>Une application en Python avec interface graphique Tkinter permettant :</p>
        <ul>
          <li> Capture vidéo en direct via la webcam : Utilise OpenCV pour afficher le flux vidéo dans une interface Tkinter</li>
          <li>Détection de mouvement : Compare les images successives en niveaux de gris pour détecter un changement significatif (mouvement)</li>
          <li>Enregistrement automatique : Lance un enregistrement vidéo (format .avi) lorsqu’un mouvement est détecté, et l’arrête après 5 secondes d’inactivité</li>
          <li>Alerte sonore et message pop-up : Lorsqu’un mouvement est détecté, le programme joue un son d’alerte (alerte.mp3) et affiche une notification à l’écran</li>
        </ul>

          <p><strong>Code source :</strong></p>
          <details>
            <summary>Afficher/masquer le script complet</summary>
            <pre><code class="language-python">
"""
Created on Mon Jun  9 12:30:45 2025
@author: NGAKI MUPATI NADAL
"""

import tkinter as tk  # Pour créer l'interface graphique
import cv2  # OpenCV pour la capture vidéo et le traitement d'image
# import face_recognition  # (Désactivé ici, pas utilisé dans cette version)
from PIL import Image, ImageTk  # Pour afficher les images OpenCV dans Tkinter
from tkinter import messagebox  # Pour afficher des messages pop-up
import time  # Pour mesurer le temps écoulé (utile pour l'enregistrement)
from playsound import playsound  # Pour jouer un fichier audio (alerte sonore)


class SurveillanceApp:
    def __init__(self, root):
        self.root = root  
        self.root.title("Système de vidéosurveillance intelligent") 
        self.root.geometry("800x600") 

        # Initialisation des variables de contrôle
        self.video_capture = None         # Objet pour capturer la vidéo (webcam)
        self.running = False              # Indique si la caméra tourne
        self.previous_frame = None        # Image précédente en niveaux de gris (pour comparaison)
        self.video_writer = None          # Objet pour écrire les vidéos sur le disque
        self.recording = False            # Indique si un enregistrement est en cours
        self.last_motion_time = None      # Mémorise le moment du dernier mouvement

        # Interface graphique avec Tkinter
        self.label_video = tk.Label(self.root)  # Étiquette pour afficher la vidéo
        self.label_video.pack(pady=10)

        # Bouton pour démarrer la caméra
        self.btn_start = tk.Button(self.root, text="Démarrer", command=self.start_camera)
        self.btn_start.pack(side=tk.LEFT, padx=20)

        # Bouton pour arrêter la caméra
        self.btn_stop = tk.Button(self.root, text="Arrêter", command=self.stop_camera, state=tk.DISABLED)
        self.btn_stop.pack(side=tk.LEFT, padx=20)

        # Bouton pour quitter l'application
        self.btn_quit = tk.Button(self.root, text="Quitter", command=self.quit_app)
        self.btn_quit.pack(side=tk.RIGHT, padx=20)

    def start_camera(self):
        # Ouvre la webcam (0 = webcam par défaut du PC)
        self.video_capture = cv2.VideoCapture(0)
        self.running = True  # Active la boucle de mise à jour
        self.btn_start.config(state=tk.DISABLED)
        self.btn_stop.config(state=tk.NORMAL)
        self.MiseAJour_cadre()  # Commence à lire les images

    def MiseAJour_cadre(self):
        # Fonction appelée en boucle pour afficher la vidéo et détecter les mouvements
        if self.running:
            ret, frame = self.video_capture.read()  # Capture une image
            if ret:
                # Convertit l'image couleur en niveaux de gris
                frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                # Applique un flou pour réduire les petits mouvements (bruit)
                frame_gray = cv2.GaussianBlur(frame_gray, (21, 21), 0)

                if self.previous_frame is None:
                    # Première image, on la garde pour comparer plus tard
                    self.previous_frame = frame_gray
                else:
                    # Compare l'image actuelle avec la précédente
                    diff = cv2.absdiff(self.previous_frame, frame_gray)
                    _, thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)  # Binarise la différence
                    motion_level = cv2.countNonZero(thresh)  # Compte les pixels blancs (changements)

                    if motion_level > 5000:  # Si beaucoup de pixels ont changé → mouvement détecté
                        self.last_motion_time = time.time()  # On enregistre le moment du mouvement

                        if not self.recording:
                            # Si on ne filmait pas encore → démarrer un nouvel enregistrement
                            fourcc = cv2.VideoWriter_fourcc(*'XVID')  # Format de vidéo .avi
                            self.video_writer = cv2.VideoWriter("mouvement.avi", fourcc, 20.0, (frame.shape[1], frame.shape[0]))
                            self.recording = True  # Indique qu'on est en train d'enregistrer
                            messagebox.showinfo("Détection", "Mouvement détecté - enregistrement lancé")

                            # Alerte sonore
                            playsound("alerte.mp3", block=False)

                        # Enregistrement actif : on ajoute chaque image capturée à la vidéo
                        if self.video_writer is not None:
                            self.video_writer.write(frame)

                    # Si 5 secondes sont passées sans mouvement → arrêter l'enregistrement
                    if self.recording and self.last_motion_time and (time.time() - self.last_motion_time > 5):
                        self.video_writer.release()  # Ferme le fichier vidéo
                        self.video_writer = None
                        self.recording = False
                        messagebox.showinfo("Info", "Enregistrement terminé")

                    # Sauvegarder la dernière image pour la prochaine comparaison
                    self.previous_frame = frame_gray

                # Affiche l'image actuelle dans l'interface graphique
                img = Image.fromarray(frame)  # Convertit OpenCV → Image PIL
                imgtk = ImageTk.PhotoImage(image=img)  # Convertit Image PIL → Tkinter
                self.label_video.imgtk = imgtk
                self.label_video.configure(image=imgtk)

            # Rappelle cette fonction après 10 ms (boucle d'actualisation)
            self.root.after(10, self.MiseAJour_cadre)

    def stop_camera(self):
        # Arrête la caméra et libère les ressources
        self.running = False
        self.btn_start.config(state=tk.NORMAL)
        self.btn_stop.config(state=tk.DISABLED)
        if self.video_capture:
            self.video_capture.release()
            self.label_video.config(image="")

        self.previous_frame = None  # Réinitialise l'image précédente

        # Si une vidéo était en cours → on la termine proprement
        if self.recording and self.video_writer:
            self.video_writer.release()
            self.video_writer = None
            self.recording = False

    def quit_app(self):
        # Ferme proprement l'application
        self.stop_camera()
        self.root.destroy()


# Lancement de l'application principale
if __name__ == "__main__":
    root = tk.Tk()
    app = SurveillanceApp(root)
    root.mainloop()

      </code></pre>
            </details>
        <p>
          🔽 <a href="SurveillanceVideo.py" download>Télécharger le script Python</a><br>
          🔗 <a href="https://github.com/tonpseudo/eco-guerrier" target="_blank">Voir le projet sur GitHub</a>
        </p>
  </li>

  <footer>
    <p>Contact : nadalngaki@gmail.com</p>
  </footer>
</body>
</html>
